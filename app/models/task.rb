class Task < ApplicationRecord
  include Discard::Model

  belongs_to :project
  belongs_to :agent
  belongs_to :user
  has_many :runs, dependent: :destroy
  has_many :volume_mounts, dependent: :destroy

  after_create :create_volume_mounts

  def run(prompt)
    run = runs.create!(prompt: prompt)
    RunJob.perform_later(run.id)
    run
  end

  def workplace_mount
    @workplace_mount ||= volume_mounts.find_or_create_by!(volume: nil) do |vm|
      # volume_name will be generated by the before_validation callback
    end
  end

  def fetch_branches
    return [] unless project.repository_url.present?

    repo_path = project.repo_path.presence || ""
    working_dir = workplace_mount.container_path
    git_working_dir = File.join([ working_dir, repo_path.presence&.sub(/^\//, "") ].compact)

    git_container = Docker::Container.create(
      "Image" => agent.docker_image,
      "Entrypoint" => [ "sh" ],
      "Cmd" => [ "-c", "git branch" ],
      "WorkingDir" => git_working_dir,
      "User" => agent.user_id.to_s,
      "HostConfig" => {
        "Binds" => [ workplace_mount.bind_string ]
      }
    )

    git_container.start
    wait_result = git_container.wait(30)
    logs = git_container.logs(stdout: true, stderr: true)
    branches_output = logs.gsub(/^.{8}/m, "").force_encoding("UTF-8").scrub.strip
    exit_code = wait_result["StatusCode"] if wait_result.is_a?(Hash)

    if exit_code && exit_code == 0
      Rails.logger.info "Branch fetch output: #{branches_output.inspect}"
      branches_output.split("\n").map do |line|
        line.sub(/^\*?\s*/, "").strip
      end.reject(&:empty?).sort
    else
      Rails.logger.error "Branch fetch failed with exit code: #{exit_code}, output: #{branches_output}"
      []
    end
  rescue => e
    Rails.logger.error "Failed to fetch branches: #{e.message}"
    []
  ensure
    git_container&.delete(force: true) if defined?(git_container)
  end

  def push_changes_to_branch(commit_message = nil)
    return unless auto_push_enabled? && auto_push_branch.present?
    return unless project.repository_url.present?

    repo_path = project.repo_path.presence || ""
    working_dir = workplace_mount.container_path
    git_working_dir = File.join([ working_dir, repo_path.presence&.sub(/^\//, "") ].compact)

    repository_url = project.repository_url_with_token(user)
    commit_message ||= "Manual push from SummonCircle"

    push_commands = [
      "git remote set-url origin '#{repository_url}'",
      "git add -A",
      "git diff --cached --quiet || git commit -m '#{commit_message}'",
      "git push origin HEAD:#{auto_push_branch}"
    ].join(" && ")

    push_container = Docker::Container.create(
      "Image" => agent.docker_image,
      "Entrypoint" => [ "sh" ],
      "Cmd" => [ "-c", push_commands ],
      "WorkingDir" => git_working_dir,
      "User" => agent.user_id.to_s,
      "Env" => agent.env_strings + project.secrets.map { |s| "#{s.key}=#{s.value}" },
      "HostConfig" => {
        "Binds" => volume_mounts.includes(:volume).map(&:bind_string)
      }
    )

    push_container.start

    wait_result = push_container.wait(300)
    logs = push_container.logs(stdout: true, stderr: true)
    clean_logs = logs.gsub(/^.{8}/m, "").force_encoding("UTF-8").scrub.strip
    exit_code = wait_result["StatusCode"] if wait_result.is_a?(Hash)

    if exit_code && exit_code == 0
      Rails.logger.info "Successfully pushed changes to branch: #{auto_push_branch}"
    else
      Rails.logger.error "Failed to push changes: #{clean_logs}"
      raise "Failed to push changes: #{clean_logs}"
    end
  rescue => e
    Rails.logger.error "Push error: #{e.message}"
    raise
  ensure
    push_container&.delete(force: true) if defined?(push_container)
  end

  private

  def create_volume_mounts
    agent.volumes.each do |volume|
      volume_mounts.find_or_create_by!(volume: volume)
    end
    workplace_mount # Create workplace mount
  end
end
